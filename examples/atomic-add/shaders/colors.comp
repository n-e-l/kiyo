#version 450

/*
 * Kiyo data
 * - WORKGROUP_SIZE and NUM_IMAGES are provided by the engine
 */

layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;
layout( binding = 0, rgba8 ) uniform image2D images[NUM_IMAGES];
layout( binding = 1, r32ui ) uniform uimage2D counterImages[3];

layout( push_constant ) uniform PushConstants
{
    float time;
    int in_image;
    int out_image;
} constants;

/*
 * User data
 */

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

float gold_noise(vec2 xy, float seed) {
    return fract(tan(distance(xy * 1.61803398874989484820459, xy) * seed) * xy.x);
}

void writeColor(ivec3 color, ivec2 p)
{
    imageAtomicAdd(counterImages[0], p, color.r);
    imageAtomicAdd(counterImages[1], p, color.g);
    imageAtomicAdd(counterImages[2], p, color.b);
}

void drawDDALine(ivec2 p0, ivec2 p1, ivec3 color) {

    float dx = p0.x - p1.x;
    float dy = p0.y - p1.y;

    // Number of steps
    float steps = max(abs(dx), abs(dy));

    // Increments
    float xInc = dx / steps;
    float yInc = dy / steps;

    // Starting point
    float x = p0.x;
    float y = p0.y;

    // Draw each pixel
    for (float i = 0.0; i <= steps; i += 1.0) {
        ivec2 coord = ivec2(round(x), round(y));
        writeColor( color, coord );

        x += xInc;
        y += yInc;
    }
}

void main()
{
    ivec2 p = ivec2( gl_GlobalInvocationID.xy );
    ivec2 screenSize = imageSize( images[ constants.out_image ] );

    float r1 = gold_noise(vec2(p), 3.) * screenSize.x;
    float r2 = gold_noise(vec2(p), 5.) * screenSize.y;
//    float r1 = gold_noise(vec2(p), constants.time) * screenSize.x;
//    float r2 = gold_noise(vec2(p), constants.time + 1.3) * screenSize.y;
    vec2 center = vec2(screenSize) / 2;
    ivec2 p1 = ivec2(center + vec2(cos(r1), sin(r1)) * r2 );

    r1 = gold_noise(vec2(p), 1.) * screenSize.x;
    r2 = gold_noise(vec2(p), 3.) * screenSize.y;
//    r1 = gold_noise(vec2(p), constants.time + 20.) * screenSize.x;
//    r2 = gold_noise(vec2(p), constants.time + 5.3) * screenSize.y;
    ivec2 p2 = ivec2(center + vec2(cos(r1), sin(r1)) * r2 );

    if( p.x > screenSize.x || p.y > screenSize.y )
    {
        return;
    }

    vec2 normal = normalize( vec2( p2 ) - vec2(p1) );
    normal = vec2(-normal.y, normal.x);
    drawDDALine(p1, p2, ivec3(4, 6, 9) * 300);
}